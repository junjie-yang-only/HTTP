仅仅是已缓存的文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际区别；只是意味着到了要进行核对的时间了。

- 如果再验证的内容发生变化，缓存会读取一份新的文档副本，并将其存储在旧文档位置上，然后将文档发送给客户端。
- 如果再验证内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期时间，并对缓存中的首部进行更新就行了。 

缓存并不一定要为每一条请求验证文档的有效性--只有在文档过期时它才需要与服务器进行再验证。这样不会提供陈旧的内容，还可以节省服务器的流量，并拥有更好的用户响应时间。

#### 用条件方法实现再验证

HTTP 允许缓存向原始服务器发送一个“条件 GET”，请求服务器只有在文档与缓存中现有的副本不同的时候，才回送对象主体。将新鲜度检测和对象获取结合成单个条件 GET。向 GET 请求报文中添加一些特殊的条件首部，就可以发起条件 GET，只有条件为真时，Web 服务器才会返回对象。  

HTTP 定义了 5 个请求首部。对缓存在验证来说最有用的 2 个首部是 **If-Modified-Since** 和 **If-None-Match**。

| 首部 | 描述 |
| :----: | :-----: |
| If-Unmodified-Since | 在进行部分文件的传输时，获取文件的其余部分之前要确保文件未发生变化 |
| If-Range | 支持对不完整文档的缓存 |
| If-Match | 用于与服务器打交道时的并发控制 |
| If-Modified-Since:<date\> | 如果从指定日期之后文档被修改过了，就执行请求的方法。可以与 Last-Modified 服务器响应首部配合使用，只要在内容被修改后与已缓存版本有所不同的时候才去获取内容 |
| If-None-Match:<tags\> | 服务器可以为文档提供特殊的标签（参见 Etag），而不是将其与最近修改日期相匹配，这些标签就像序列号一样，如果已缓存标签与服务器文档中的标签有所不同，If-None_match 首部就会执行所请求的方法。 | 

